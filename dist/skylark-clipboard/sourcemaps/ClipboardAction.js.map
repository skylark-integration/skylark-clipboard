{"version":3,"sources":["ClipboardAction.js"],"names":["define","noder","[object Object]","options","this","resolveOptions","initSelection","action","container","emitter","target","text","trigger","selectedText","selectFake","selectTarget","isRTL","document","documentElement","getAttribute","removeFake","fakeHandlerCallback","fakeHandler","addEventListener","fakeElem","createElement","style","fontSize","border","padding","margin","position","yPosition","window","pageYOffset","scrollTop","top","setAttribute","value","appendChild","select","copyText","removeEventListener","removeChild","succeeded","execCommand","err","handleResult","emit","clearSelection","bind","focus","getSelection","removeAllRanges","_action","Error","undefined","nodeType","hasAttribute","_target"],"mappings":";;;;;;;AAAAA,QACI,sBACF,SAASC,GA4MP,aAjMIC,YAAYC,GACRC,KAAKC,eAAeF,GACpBC,KAAKE,gBAOTJ,eAAeC,MACXC,KAAKG,OAAYJ,EAAQI,OACzBH,KAAKI,UAAYL,EAAQK,UACzBJ,KAAKK,QAAYN,EAAQM,QACzBL,KAAKM,OAAYP,EAAQO,OACzBN,KAAKO,KAAYR,EAAQQ,KACzBP,KAAKQ,QAAYT,EAAQS,QAEzBR,KAAKS,aAAe,GAOxBX,gBACQE,KAAKO,KACLP,KAAKU,aAEAV,KAAKM,QACVN,KAAKW,eAQbb,aACI,MAAMc,EAAwD,OAAhDC,SAASC,gBAAgBC,aAAa,OAEpDf,KAAKgB,aAELhB,KAAKiB,oBAAsB,KAAMjB,KAAKgB,cACtChB,KAAKkB,YAAclB,KAAKI,UAAUe,iBAAiB,QAASnB,KAAKiB,uBAAwB,EAEzFjB,KAAKoB,SAAWP,SAASQ,cAAc,YAEvCrB,KAAKoB,SAASE,MAAMC,SAAW,OAE/BvB,KAAKoB,SAASE,MAAME,OAAS,IAC7BxB,KAAKoB,SAASE,MAAMG,QAAU,IAC9BzB,KAAKoB,SAASE,MAAMI,OAAS,IAE7B1B,KAAKoB,SAASE,MAAMK,SAAW,WAC/B3B,KAAKoB,SAASE,MAAOV,EAAQ,QAAU,QAAW,UAElD,IAAIgB,EAAYC,OAAOC,aAAejB,SAASC,gBAAgBiB,UAC/D/B,KAAKoB,SAASE,MAAMU,OAASJ,MAE7B5B,KAAKoB,SAASa,aAAa,WAAY,IACvCjC,KAAKoB,SAASc,MAAQlC,KAAKO,KAE3BP,KAAKI,UAAU+B,YAAYnC,KAAKoB,UAEhCpB,KAAKS,aAAeZ,EAAMuC,OAAOpC,KAAKoB,UACtCpB,KAAKqC,WAOTvC,aACQE,KAAKkB,cACLlB,KAAKI,UAAUkC,oBAAoB,QAAStC,KAAKiB,qBACjDjB,KAAKkB,YAAc,KACnBlB,KAAKiB,oBAAsB,MAG3BjB,KAAKoB,WACLpB,KAAKI,UAAUmC,YAAYvC,KAAKoB,UAChCpB,KAAKoB,SAAW,MAOxBtB,eACIE,KAAKS,aAAeZ,EAAMuC,OAAOpC,KAAKM,QACtCN,KAAKqC,WAMTvC,WACI,IAAI0C,EAEJ,IACIA,EAAY3B,SAAS4B,YAAYzC,KAAKG,QAE1C,MAAOuC,GACHF,GAAY,EAGhBxC,KAAK2C,aAAaH,GAOtB1C,aAAa0C,GACTxC,KAAKK,QAAQuC,KAAKJ,EAAY,UAAY,SACtCrC,OAAQH,KAAKG,OACbI,KAAMP,KAAKS,aACXD,QAASR,KAAKQ,QACdqC,eAAgB7C,KAAK6C,eAAeC,KAAK9C,QAOjDF,iBACQE,KAAKQ,SACLR,KAAKQ,QAAQuC,QAGjBlB,OAAOmB,eAAeC,kBAO1B9C,WAAWA,EAAS,QAGhB,GAFAH,KAAKkD,QAAU/C,EAEM,SAAjBH,KAAKkD,SAAuC,QAAjBlD,KAAKkD,QAChC,MAAM,IAAIC,MAAM,sDAQxBhD,aACI,OAAOH,KAAKkD,QAQhB5C,WAAWA,GACP,QAAe8C,IAAX9C,EAAsB,CACtB,IAAIA,GAA4B,iBAAXA,GAA2C,IAApBA,EAAO+C,SAY/C,MAAM,IAAIF,MAAM,+CAXhB,GAAoB,SAAhBnD,KAAKG,QAAqBG,EAAOgD,aAAa,YAC9C,MAAM,IAAIH,MAAM,qFAGpB,GAAoB,QAAhBnD,KAAKG,SAAqBG,EAAOgD,aAAa,aAAehD,EAAOgD,aAAa,aACjF,MAAM,IAAIH,MAAM,0GAGpBnD,KAAKuD,QAAUjD,GAY3BA,aACI,OAAON,KAAKuD,QAMhBzD,UACIE,KAAKgB","file":"../ClipboardAction.js","sourcesContent":["define([\n    \"skylark-domx-noder\"\n],function(noder){\n\n\n    /**\n     * Inner class which performs selection from either `text` or `target`\n     * properties and then executes copy or cut operations.\n     */\n    class ClipboardAction {\n        /**\n         * @param {Object} options\n         */\n        constructor(options) {\n            this.resolveOptions(options);\n            this.initSelection();\n        }\n\n        /**\n         * Defines base properties passed from constructor.\n         * @param {Object} options\n         */\n        resolveOptions(options = {}) {\n            this.action    = options.action;\n            this.container = options.container;\n            this.emitter   = options.emitter;\n            this.target    = options.target;\n            this.text      = options.text;\n            this.trigger   = options.trigger;\n\n            this.selectedText = '';\n        }\n\n        /**\n         * Decides which selection strategy is going to be applied based\n         * on the existence of `text` and `target` properties.\n         */\n        initSelection() {\n            if (this.text) {\n                this.selectFake();\n            }\n            else if (this.target) {\n                this.selectTarget();\n            }\n        }\n\n        /**\n         * Creates a fake textarea element, sets its value from `text` property,\n         * and makes a selection on it.\n         */\n        selectFake() {\n            const isRTL = document.documentElement.getAttribute('dir') == 'rtl';\n\n            this.removeFake();\n\n            this.fakeHandlerCallback = () => this.removeFake();\n            this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;\n\n            this.fakeElem = document.createElement('textarea');\n            // Prevent zooming on iOS\n            this.fakeElem.style.fontSize = '12pt';\n            // Reset box model\n            this.fakeElem.style.border = '0';\n            this.fakeElem.style.padding = '0';\n            this.fakeElem.style.margin = '0';\n            // Move element out of screen horizontally\n            this.fakeElem.style.position = 'absolute';\n            this.fakeElem.style[ isRTL ? 'right' : 'left' ] = '-9999px';\n            // Move element to the same position vertically\n            let yPosition = window.pageYOffset || document.documentElement.scrollTop;\n            this.fakeElem.style.top = `${yPosition}px`;\n\n            this.fakeElem.setAttribute('readonly', '');\n            this.fakeElem.value = this.text;\n\n            this.container.appendChild(this.fakeElem);\n\n            this.selectedText = noder.select(this.fakeElem);\n            this.copyText();\n        }\n\n        /**\n         * Only removes the fake element after another click event, that way\n         * a user can hit `Ctrl+C` to copy because selection still exists.\n         */\n        removeFake() {\n            if (this.fakeHandler) {\n                this.container.removeEventListener('click', this.fakeHandlerCallback);\n                this.fakeHandler = null;\n                this.fakeHandlerCallback = null;\n            }\n\n            if (this.fakeElem) {\n                this.container.removeChild(this.fakeElem);\n                this.fakeElem = null;\n            }\n        }\n\n        /**\n         * Selects the content from element passed on `target` property.\n         */\n        selectTarget() {\n            this.selectedText = noder.select(this.target);\n            this.copyText();\n        }\n\n        /**\n         * Executes the copy operation based on the current selection.\n         */\n        copyText() {\n            let succeeded;\n\n            try {\n                succeeded = document.execCommand(this.action);\n            }\n            catch (err) {\n                succeeded = false;\n            }\n\n            this.handleResult(succeeded);\n        }\n\n        /**\n         * Fires an event based on the copy operation result.\n         * @param {Boolean} succeeded\n         */\n        handleResult(succeeded) {\n            this.emitter.emit(succeeded ? 'success' : 'error', {\n                action: this.action,\n                text: this.selectedText,\n                trigger: this.trigger,\n                clearSelection: this.clearSelection.bind(this)\n            });\n        }\n\n        /**\n         * Moves focus away from `target` and back to the trigger, removes current selection.\n         */\n        clearSelection() {\n            if (this.trigger) {\n                this.trigger.focus();\n            }\n\n            window.getSelection().removeAllRanges();\n        }\n\n        /**\n         * Sets the `action` to be performed which can be either 'copy' or 'cut'.\n         * @param {String} action\n         */\n        set action(action = 'copy') {\n            this._action = action;\n\n            if (this._action !== 'copy' && this._action !== 'cut') {\n                throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n            }\n        }\n\n        /**\n         * Gets the `action` property.\n         * @return {String}\n         */\n        get action() {\n            return this._action;\n        }\n\n        /**\n         * Sets the `target` property using an element\n         * that will be have its content copied.\n         * @param {Element} target\n         */\n        set target(target) {\n            if (target !== undefined) {\n                if (target && typeof target === 'object' && target.nodeType === 1) {\n                    if (this.action === 'copy' && target.hasAttribute('disabled')) {\n                        throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                    }\n\n                    if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {\n                        throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                    }\n\n                    this._target = target;\n                }\n                else {\n                    throw new Error('Invalid \"target\" value, use a valid Element');\n                }\n            }\n        }\n\n        /**\n         * Gets the `target` property.\n         * @return {String|HTMLElement}\n         */\n        get target() {\n            return this._target;\n        }\n\n        /**\n         * Destroy lifecycle.\n         */\n        destroy() {\n            this.removeFake();\n        }\n    }\n\n    return ClipboardAction;\n});\n"]}