{"version":3,"sources":["skylark-clipboard.js"],"names":["define","noder","[object Object]","options","this","resolveOptions","initSelection","action","container","emitter","target","text","trigger","selectedText","selectFake","selectTarget","isRTL","document","documentElement","getAttribute","removeFake","fakeHandlerCallback","fakeHandler","addEventListener","fakeElem","createElement","style","fontSize","border","padding","margin","position","yPosition","window","pageYOffset","scrollTop","top","setAttribute","value","appendChild","select","copyText","removeEventListener","removeChild","succeeded","execCommand","err","handleResult","emit","clearSelection","bind","focus","getSelection","removeAllRanges","_action","Error","undefined","nodeType","hasAttribute","_target","skylark","Emitter","eventer","ClipboardAction","getAttributeValue","suffix","element","attribute","attach","super","listenClick","defaultAction","defaultTarget","defaultText","body","self","callback","e","onClick","on","listener","destroy","off","delegateTarget","currentTarget","clipboardAction","selector","querySelector","actions","support","queryCommandSupported","forEach","Clipboard","main"],"mappings":";;;;;;;g4BAAAA,EAAA,qCACA,sBACA,SAAAC,GA2HA,aAhHAC,YAAAC,GACAC,KAAAC,eAAAF,GACAC,KAAAE,gBAOAJ,eAAAC,MACAC,KAAAG,OAAAJ,EAAAI,OACAH,KAAAI,UAAAL,EAAAK,UACAJ,KAAAK,QAAAN,EAAAM,QACAL,KAAAM,OAAAP,EAAAO,OACAN,KAAAO,KAAAR,EAAAQ,KACAP,KAAAQ,QAAAT,EAAAS,QAEAR,KAAAS,aAAA,GAOAX,gBACAE,KAAAO,KACAP,KAAAU,aAEAV,KAAAM,QACAN,KAAAW,eAQAb,aACA,MAAAc,EAAA,OAAAC,SAAAC,gBAAAC,aAAA,OAEAf,KAAAgB,aAEAhB,KAAAiB,oBAAA,KAAAjB,KAAAgB,cACAhB,KAAAkB,YAAAlB,KAAAI,UAAAe,iBAAA,QAAAnB,KAAAiB,uBAAA,EAEAjB,KAAAoB,SAAAP,SAAAQ,cAAA,YAEArB,KAAAoB,SAAAE,MAAAC,SAAA,OAEAvB,KAAAoB,SAAAE,MAAAE,OAAA,IACAxB,KAAAoB,SAAAE,MAAAG,QAAA,IACAzB,KAAAoB,SAAAE,MAAAI,OAAA,IAEA1B,KAAAoB,SAAAE,MAAAK,SAAA,WACA3B,KAAAoB,SAAAE,MAAAV,EAAA,QAAA,QAAA,UAEA,IAAAgB,EAAAC,OAAAC,aAAAjB,SAAAC,gBAAAiB,UACA/B,KAAAoB,SAAAE,MAAAU,OAAAJ,MAEA5B,KAAAoB,SAAAa,aAAA,WAAA,IACAjC,KAAAoB,SAAAc,MAAAlC,KAAAO,KAEAP,KAAAI,UAAA+B,YAAAnC,KAAAoB,UAEApB,KAAAS,aAAAZ,EAAAuC,OAAApC,KAAAoB,UACApB,KAAAqC,WA1EAvC,aACAE,KAAAkB,cACAlB,KAAAI,UAAAkC,oBAAA,QAAAtC,KAAAiB,qBACAjB,KAAAkB,YAAA,KACAlB,KAAAiB,oBAAA,MAGAjB,KAAAoB,WACApB,KAAAI,UAAAmC,YAAAvC,KAAAoB,UACApB,KAAAoB,SAAA,MAOAtB,eACAE,KAAAS,aAAAZ,EAAAuC,OAAApC,KAAAM,QACAN,KAAAqC,WAMAvC,WACA,IAAA0C,EAEA,IACAA,EAAA3B,SAAA4B,YAAAzC,KAAAG,QAEA,MAAAuC,GACAF,GAAA,EAGAxC,KAAA2C,aAAAH,GAOA1C,aAAA0C,GACAxC,KAAAK,QAAAuC,KAAAJ,EAAA,UAAA,SACArC,OAAAH,KAAAG,OACAI,KAAAP,KAAAS,aACAD,QAAAR,KAAAQ,QACAqC,eAAA7C,KAAA6C,eAAAC,KAAA9C,QAOAF,iBACAE,KAAAQ,SACAR,KAAAQ,QAAAuC,QAGAlB,OAAAmB,eAAAC,kBAOA9C,WAAAA,EAAA,QAGA,GAFAH,KAAAkD,QAAA/C,EAEA,SAAAH,KAAAkD,SAAA,QAAAlD,KAAAkD,QACA,MAAA,IAAAC,MAAA,sDAQAhD,aACA,OAAAH,KAAAkD,QAQA5C,WAAAA,GACA,QAAA8C,IAAA9C,EAAA,CACA,IAAAA,GAAA,iBAAAA,GAAA,IAAAA,EAAA+C,SAYA,MAAA,IAAAF,MAAA,+CAXA,GAAA,SAAAnD,KAAAG,QAAAG,EAAAgD,aAAA,YACA,MAAA,IAAAH,MAAA,qFAGA,GAAA,QAAAnD,KAAAG,SAAAG,EAAAgD,aAAA,aAAAhD,EAAAgD,aAAA,aACA,MAAA,IAAAH,MAAA,0GAGAnD,KAAAuD,QAAAjD,GAYAA,aACA,OAAAN,KAAAuD,QAMAzD,UACAE,KAAAgB,iBAOApB,EAAA,+BACA,wBACA,wBACA,uBACA,qBACA,SAAA4D,EAAAC,EAAAC,EAAAC,GAsIA,SAAAC,EAAAC,EAAAC,GACA,MAAAC,oBAAAF,IAEA,GAAAC,EAAAR,aAAAS,GAIA,OAAAD,EAAA/C,aAAAgD,GAGA,OAAAP,EAAAQ,OAAA,+BAzIAP,EAKA3D,YAAAU,EAAAT,GACAkE,QAEAjE,KAAAC,eAAAF,GACAC,KAAAkE,YAAA1D,GAQAV,eAAAC,MACAC,KAAAG,OAAA,mBAAAJ,EAAAI,OAAAJ,EAAAI,OAAAH,KAAAmE,cACAnE,KAAAM,OAAA,mBAAAP,EAAAO,OAAAP,EAAAO,OAAAN,KAAAoE,cACApE,KAAAO,KAAA,mBAAAR,EAAAQ,KAAAR,EAAAQ,KAAAP,KAAAqE,YACArE,KAAAI,UAAA,iBAAAL,EAAAK,UAAAL,EAAAK,UAAAS,SAAAyD,KAOAxE,YAAAU,GACA,IAAA+D,EAAAvE,KACAwE,EAAA,SAAAC,GACAF,EAAAG,QAAAD,IAGAf,EAAAiB,GAAAnE,EAAA,QAAAgE,GAEAxE,KAAA4E,UACAC,QAAA,WACAnB,EAAAoB,IAAAtE,EAAA,QAAAgE,KASA1E,QAAA2E,GACA,MAAAjE,EAAAiE,EAAAM,gBAAAN,EAAAO,cAEAhF,KAAAiF,kBACAjF,KAAAiF,gBAAA,MAGAjF,KAAAiF,gBAAA,IAAAtB,GACAxD,OAAAH,KAAAG,OAAAK,GACAF,OAAAN,KAAAM,OAAAE,GACAD,KAAAP,KAAAO,KAAAC,GACAJ,UAAAJ,KAAAI,UACAI,QAAAA,EACAH,QAAAL,OAQAF,cAAAU,GACA,OAAAoD,EAAA,SAAApD,GAOAV,cAAAU,GACA,MAAA0E,EAAAtB,EAAA,SAAApD,GAEA,GAAA0E,EACA,OAAArE,SAAAsE,cAAAD,GASApF,mBAAAK,GAAA,OAAA,QACA,MAAAiF,EAAA,iBAAAjF,GAAAA,GAAAA,EACA,IAAAkF,IAAAxE,SAAAyE,sBAMA,OAJAF,EAAAG,QAAApF,IACAkF,EAAAA,KAAAxE,SAAAyE,sBAAAnF,KAGAkF,EAOAvF,YAAAU,GACA,OAAAoD,EAAA,OAAApD,GAMAV,UACAE,KAAA4E,SAAAC,UAEA7E,KAAAiF,kBACAjF,KAAAiF,gBAAAJ,UACA7E,KAAAiF,gBAAA,WA2BArF,EAAA,0BACA,eACA,SAAA4F,GACA,OAAAA,IAEA5F,EAAA,qBAAA,0BAAA,SAAA6F,GAAA,OAAAA","file":"../skylark-clipboard.js","sourcesContent":["define('skylark-clipboard/ClipboardAction',[\n    \"skylark-domx-noder\"\n],function(noder){\n\n\n    /**\n     * Inner class which performs selection from either `text` or `target`\n     * properties and then executes copy or cut operations.\n     */\n    class ClipboardAction {\n        /**\n         * @param {Object} options\n         */\n        constructor(options) {\n            this.resolveOptions(options);\n            this.initSelection();\n        }\n\n        /**\n         * Defines base properties passed from constructor.\n         * @param {Object} options\n         */\n        resolveOptions(options = {}) {\n            this.action    = options.action;\n            this.container = options.container;\n            this.emitter   = options.emitter;\n            this.target    = options.target;\n            this.text      = options.text;\n            this.trigger   = options.trigger;\n\n            this.selectedText = '';\n        }\n\n        /**\n         * Decides which selection strategy is going to be applied based\n         * on the existence of `text` and `target` properties.\n         */\n        initSelection() {\n            if (this.text) {\n                this.selectFake();\n            }\n            else if (this.target) {\n                this.selectTarget();\n            }\n        }\n\n        /**\n         * Creates a fake textarea element, sets its value from `text` property,\n         * and makes a selection on it.\n         */\n        selectFake() {\n            const isRTL = document.documentElement.getAttribute('dir') == 'rtl';\n\n            this.removeFake();\n\n            this.fakeHandlerCallback = () => this.removeFake();\n            this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;\n\n            this.fakeElem = document.createElement('textarea');\n            // Prevent zooming on iOS\n            this.fakeElem.style.fontSize = '12pt';\n            // Reset box model\n            this.fakeElem.style.border = '0';\n            this.fakeElem.style.padding = '0';\n            this.fakeElem.style.margin = '0';\n            // Move element out of screen horizontally\n            this.fakeElem.style.position = 'absolute';\n            this.fakeElem.style[ isRTL ? 'right' : 'left' ] = '-9999px';\n            // Move element to the same position vertically\n            let yPosition = window.pageYOffset || document.documentElement.scrollTop;\n            this.fakeElem.style.top = `${yPosition}px`;\n\n            this.fakeElem.setAttribute('readonly', '');\n            this.fakeElem.value = this.text;\n\n            this.container.appendChild(this.fakeElem);\n\n            this.selectedText = noder.select(this.fakeElem);\n            this.copyText();\n        }\n\n        /**\n         * Only removes the fake element after another click event, that way\n         * a user can hit `Ctrl+C` to copy because selection still exists.\n         */\n        removeFake() {\n            if (this.fakeHandler) {\n                this.container.removeEventListener('click', this.fakeHandlerCallback);\n                this.fakeHandler = null;\n                this.fakeHandlerCallback = null;\n            }\n\n            if (this.fakeElem) {\n                this.container.removeChild(this.fakeElem);\n                this.fakeElem = null;\n            }\n        }\n\n        /**\n         * Selects the content from element passed on `target` property.\n         */\n        selectTarget() {\n            this.selectedText = noder.select(this.target);\n            this.copyText();\n        }\n\n        /**\n         * Executes the copy operation based on the current selection.\n         */\n        copyText() {\n            let succeeded;\n\n            try {\n                succeeded = document.execCommand(this.action);\n            }\n            catch (err) {\n                succeeded = false;\n            }\n\n            this.handleResult(succeeded);\n        }\n\n        /**\n         * Fires an event based on the copy operation result.\n         * @param {Boolean} succeeded\n         */\n        handleResult(succeeded) {\n            this.emitter.emit(succeeded ? 'success' : 'error', {\n                action: this.action,\n                text: this.selectedText,\n                trigger: this.trigger,\n                clearSelection: this.clearSelection.bind(this)\n            });\n        }\n\n        /**\n         * Moves focus away from `target` and back to the trigger, removes current selection.\n         */\n        clearSelection() {\n            if (this.trigger) {\n                this.trigger.focus();\n            }\n\n            window.getSelection().removeAllRanges();\n        }\n\n        /**\n         * Sets the `action` to be performed which can be either 'copy' or 'cut'.\n         * @param {String} action\n         */\n        set action(action = 'copy') {\n            this._action = action;\n\n            if (this._action !== 'copy' && this._action !== 'cut') {\n                throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n            }\n        }\n\n        /**\n         * Gets the `action` property.\n         * @return {String}\n         */\n        get action() {\n            return this._action;\n        }\n\n        /**\n         * Sets the `target` property using an element\n         * that will be have its content copied.\n         * @param {Element} target\n         */\n        set target(target) {\n            if (target !== undefined) {\n                if (target && typeof target === 'object' && target.nodeType === 1) {\n                    if (this.action === 'copy' && target.hasAttribute('disabled')) {\n                        throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                    }\n\n                    if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {\n                        throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                    }\n\n                    this._target = target;\n                }\n                else {\n                    throw new Error('Invalid \"target\" value, use a valid Element');\n                }\n            }\n        }\n\n        /**\n         * Gets the `target` property.\n         * @return {String|HTMLElement}\n         */\n        get target() {\n            return this._target;\n        }\n\n        /**\n         * Destroy lifecycle.\n         */\n        destroy() {\n            this.removeFake();\n        }\n    }\n\n    return ClipboardAction;\n});\n\ndefine('skylark-clipboard/Clipboard',[\n    \"skylark-langx/skylark\",\n    \"skylark-langx/Emitter\",\n    \"skylark-domx-eventer\",\n    \"./ClipboardAction\"\n],function(skylark,Emitter,eventer,ClipboardAction){\n\n\n    /**\n     * Base class which takes one or more elements, adds event listeners to them,\n     * and instantiates a new `ClipboardAction` on each click.\n     */\n    class Clipboard extends Emitter {\n        /**\n         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n         * @param {Object} options\n         */\n        constructor(trigger, options) {\n            super();\n\n            this.resolveOptions(options);\n            this.listenClick(trigger);\n        }\n\n        /**\n         * Defines if attributes would be resolved using internal setter functions\n         * or custom functions that were passed in the constructor.\n         * @param {Object} options\n         */\n        resolveOptions(options = {}) {\n            this.action    = (typeof options.action    === 'function') ? options.action    : this.defaultAction;\n            this.target    = (typeof options.target    === 'function') ? options.target    : this.defaultTarget;\n            this.text      = (typeof options.text      === 'function') ? options.text      : this.defaultText;\n            this.container = (typeof options.container === 'object')   ? options.container : document.body;\n        }\n\n        /**\n         * Adds a click event listener to the passed trigger.\n         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n         */\n        listenClick(trigger) {\n            var self = this,\n                callback = function(e) {\n                    self.onClick(e);\n                };\n\n            eventer.on(trigger, 'click', callback);\n\n            this.listener = {\n                destroy : function(){\n                    eventer.off(trigger,'click',callback);\n                }\n            };\n        }\n\n        /**\n         * Defines a new `ClipboardAction` on each click event.\n         * @param {Event} e\n         */\n        onClick(e) {\n            const trigger = e.delegateTarget || e.currentTarget;\n\n            if (this.clipboardAction) {\n                this.clipboardAction = null;\n            }\n\n            this.clipboardAction = new ClipboardAction({\n                action    : this.action(trigger),\n                target    : this.target(trigger),\n                text      : this.text(trigger),\n                container : this.container,\n                trigger   : trigger,\n                emitter   : this\n            });\n        }\n\n        /**\n         * Default `action` lookup function.\n         * @param {Element} trigger\n         */\n        defaultAction(trigger) {\n            return getAttributeValue('action', trigger);\n        }\n\n        /**\n         * Default `target` lookup function.\n         * @param {Element} trigger\n         */\n        defaultTarget(trigger) {\n            const selector = getAttributeValue('target', trigger);\n\n            if (selector) {\n                return document.querySelector(selector);\n            }\n        }\n\n        /**\n         * Returns the support of the given action, or all actions if no action is\n         * given.\n         * @param {String} [action]\n         */\n        static isSupported(action = ['copy', 'cut']) {\n            const actions = (typeof action === 'string') ? [action] : action;\n            let support = !!document.queryCommandSupported;\n\n            actions.forEach((action) => {\n                support = support && !!document.queryCommandSupported(action);\n            });\n\n            return support;\n        }\n\n        /**\n         * Default `text` lookup function.\n         * @param {Element} trigger\n         */\n        defaultText(trigger) {\n            return getAttributeValue('text', trigger);\n        }\n\n        /**\n         * Destroy lifecycle.\n         */\n        destroy() {\n            this.listener.destroy();\n\n            if (this.clipboardAction) {\n                this.clipboardAction.destroy();\n                this.clipboardAction = null;\n            }\n        }\n    }\n\n\n    /**\n     * Helper function to retrieve attribute value.\n     * @param {String} suffix\n     * @param {Element} element\n     */\n    function getAttributeValue(suffix, element) {\n        const attribute = `data-clipboard-${suffix}`;\n\n        if (!element.hasAttribute(attribute)) {\n            return;\n        }\n\n        return element.getAttribute(attribute);\n    }\n\n    return skylark.attach(\"intg.Clipboard\",Clipboard);\n\n\n});\n\n\ndefine('skylark-clipboard/main',[\r\n\t\"./Clipboard\"\r\n],function(Clipboard){\r\n\treturn Clipboard;\r\n});\ndefine('skylark-clipboard', ['skylark-clipboard/main'], function (main) { return main; });\n\n"]}